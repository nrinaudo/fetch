package com.nrinaudo.fetch

import org.scalatest.{BeforeAndAfterAll, FunSpec}
import org.scalatest.matchers.ShouldMatchers
import org.scalatest.prop.GeneratorDrivenPropertyChecks
import org.scalacheck.{Arbitrary, Gen}
import Arbitrary._
import com.nrinaudo.fetch.net.UrlEngine
import java.nio.charset.Charset
import scala.collection.JavaConverters._
import java.util.Locale
import java.io._
import scala.Some
import com.nrinaudo.fetch.Request.Conneg

object RequestSpec {
  // - Basic generators ------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------------------
  /** Generates random, legal HTTP methods. */
  def httpMethod = Gen.oneOf("GET", "POST", "PUT", "DELETE", "OPTIONS", "TRACE", "PATCH", "LINK", "UNLINK")

  /** Helper generator, discards empty values generated by its arguments. */
  def nonEmpty(gen: Gen[String]) = gen.suchThat {!_.isEmpty}



  // - Request entity generation ---------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------------------
  // Temporary file used to store request entities.
  private lazy val tmpFile: File = {
    val f = File.createTempFile("fetch", "request")
    f.deleteOnExit()
    f
  }

  /** Generates a temporary file containing the specified content (UTF-8 encoded). */
  def tmpFile(content: String): File = {
    val out = new OutputStreamWriter(new FileOutputStream(tmpFile), DefaultCharset)
    try {out.write(content)}
    finally {out.close()}

    tmpFile
  }

  /** Represents an entity and its expected content one serialized.
    *
    * This is meant for tests where an entity is written to and sent back by a remote server and needs to be compared
    * with its original value.
    */
  case class KnownEntity(content: String, entity: RequestEntity)

  def entity = for {
    content <- nonEmpty(arbitrary[String])
    impl    <- Gen.choose(0, 5)
  } yield KnownEntity(content, (impl match {
      case 0 => RequestEntity.bytes(out => out.write(content.getBytes(DefaultCharset)))
      case 1 => RequestEntity.chars(out => out.write(content))
      case 2 => RequestEntity(new ByteArrayInputStream(content.getBytes(DefaultCharset)))
      case 3 => RequestEntity(new StringReader(content))
      case 4 => RequestEntity(content)
      case 5 => RequestEntity(content)
      case e => throw new AssertionError("Unexpected rand(0, 5) value: " + e)
    }).mimeType(MimeType.TextPlain.charset(DefaultCharset)))




  // - Basic auth generators -------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------------------
  // Note that this is not entirely correct: according to the RFC, password are allowed to contain a ':'. This is not
  // properly handled in version 0.7.1 of unfiltered, however (the issue is fixed in github, but not yet released).
  def authCredentials = for {
    user <- nonEmpty(arbitrary[String]).suchThat {!_.contains(':')}
    pwd <- nonEmpty(arbitrary[String]).suchThat {!_.contains(':')}
  } yield (user, pwd)



  // - Content negotiation generators ----------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------------------
  def encoding = Gen.oneOf(Encoding.Gzip, Encoding.Deflate, Encoding.Identity)

  private lazy val charsets = Charset.availableCharsets().values().asScala.toList
  def charset: Gen[Charset] = Gen.oneOf(charsets)

  def language = Gen.oneOf(Locale.getAvailableLocales)

  def conneg[T](gen: Gen[T]) = for {
    value <- gen
    q     <- arbitrary[Float]
  } yield Conneg(value, math.abs(q / Float.MaxValue))

  def connegs[T](gen: Gen[T]) = for {
    l    <- Gen.choose(1, 10)
    list <- Gen.listOfN(l, conneg(gen))
  } yield list

  val connegValue = "([^;]+)(?:;q=(.*))?".r
}

class RequestSpec extends FunSpec with BeforeAndAfterAll with ShouldMatchers with GeneratorDrivenPropertyChecks {
  import RequestSpec._



  // - Test HTTP server ------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------------------
  val server = unfiltered.jetty.Http.anylocal.plan(TestPlan)

  implicit val engine = UrlEngine()

  def request(path: String) = Request(server.url + path)

  override def beforeAll(conf: Map[String, Any]) {
    server.start()
  }

  override def afterAll(conf: Map[String, Any]) {
    server.stop()
  }



  // - Actual tests ----------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------------------
  describe("A Request") {
    // - Basic tests ---------------------------------------------------------------------------------------------------
    // -----------------------------------------------------------------------------------------------------------------
    it("should use the specified HTTP method") {
      forAll(httpMethod) { method =>
        request("method").method(method).apply().body.as[String] should be(method)
      }
    }

    it("should extract the correct HTTP status codes") {
      forAll(Gen.choose(200, 599)) { code =>
        request("status/" + code)().status should be(Status(code))
      }
    }



    // - Entity submission / reception ---------------------------------------------------------------------------------
    // -----------------------------------------------------------------------------------------------------------------
    it("should correctly read and write entity bodies, regardless of the request and response encoding") {
      forAll(entity, encoding, encoding) { (entity, reqEncoding, resEncoding) =>
        val response = request("body").acceptEncoding(resEncoding).PUT(entity.entity.encoding(reqEncoding))

        if(resEncoding == Encoding.Identity) response.headers.get("Content-Encoding") should be(None)
        else                                 response.headers.get("Content-Encoding") should be(Some(List(resEncoding.name)))

        response.body.as[String] should be(entity.content)
      }
    }



    // - Header helpers ------------------------------------------------------------------------------------------------
    // -----------------------------------------------------------------------------------------------------------------
    def checkConneg[T](response: Response[ResponseEntity], values: List[Conneg[T]])(f: T => String) =
      response.body.as[String].split("\n").zip(values).foreach {
        case (connegValue(param, q), value) =>
          param should be(f(value.value))
          if(q == null) value.q should be(1)
          else (math.round(value.q * 1000) / 1000f) should be(q.toFloat)
      }


    it("should use the specified Accept header(s), discarding parameters if any is present") {
      forAll(connegs(MimeTypeSpec.mimeType)) { mimeTypes =>
        checkConneg(request("header/Accept").accept(mimeTypes :_*).GET(), mimeTypes) { mimeType =>
          mimeType.main + "/" + mimeType.sub
        }
      }
    }

    it("should use the specified Accept-Charset header") {
      forAll(connegs(charset)) { charsets =>
        checkConneg(request("header/Accept-Charset").acceptCharset(charsets :_*).GET(), charsets)(_.name())
      }
    }

    it("should use the specified Accept-Language header") {
      forAll(connegs(language)) { languages =>
        checkConneg(request("header/Accept-Language").acceptLanguage(languages :_*).GET(), languages) { lang =>
          lang.getLanguage + (if(lang.getCountry.isEmpty) "" else "-" + lang.getCountry)
        }
      }
    }

    it("should use the specified Accept-Encoding header") {
      forAll(connegs(encoding)) { encodings =>
        checkConneg(request("header/Accept-Encoding").acceptEncoding(encodings :_*).GET(), encodings)(_.name)
      }
    }


    // - BasicAuth -----------------------------------------------------------------------------------------------------
    // -----------------------------------------------------------------------------------------------------------------
    it("should send basic auth credentials properly") {
      forAll(authCredentials) {case (user, pwd) =>
        request("auth").auth(user, pwd)().body.as[String] should be(user + "\n" + pwd)
      }
    }
  }
}
